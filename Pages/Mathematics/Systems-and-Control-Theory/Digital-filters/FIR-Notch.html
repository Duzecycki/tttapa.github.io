<!DOCTYPE HTML>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
    <head>
        <meta charset="UTF-8"/>
        <meta name="author" content="Pieter P"/>
        <link rel="stylesheet" type="text/css" href="/CSS/Pages.css"/>
        <link href='/CSS/roboto.css' rel='stylesheet' type='text/css'/>
        <link href='/CSS/icon.css' rel='stylesheet' type='text/css'/>
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
              TeX: { equationNumbers: { autoNumber: "AMS" } },
              "fast-preview": {
                disabled: true
              }
            });
        </script>
        <script type="text/javascript" src="/MathJax/MathJax.js?config=TeX-AMS_SVG"></script>
        <meta content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' name='viewport'/>
        <meta name="theme-color" content="#ccc"/>
        <meta name="keywords" content="notch, digital filters, discrete-time, notch filter, FIR, FIR filter"/>
        <meta name="description" content="Designing a simple FIR notch filter to suppress a single frequency."/>
        <title>Simple Finite Impulse Response Notch Filter</title>
    </head>
    <body>
        <nav>
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 48 48" style="position:absolute;top:4px;right: 4px;">
                    <path d="M0 0h48v48h-48z" fill="none"/>
                    <path d="M6 36h36v-4h-36v4zm0-10h36v-4h-36v4zm0-14v4h36v-4h-36z"/>
                </svg>
                <h2><a href="/">Pages</a></h2>
<ul>
  <li><span class="dtriangle" onclick="this.parentElement.classList.toggle('expanded');"></span><a href="/Pages/Arduino">Arduino</a>
  <ul>
    <li><span class="dtriangle" onclick="this.parentElement.classList.toggle('expanded');"></span><a href="/Pages/Arduino/Bootloaders">Bootloaders</a>
    <ul>
    </ul>
    </li>
    <li><span class="dtriangle" onclick="this.parentElement.classList.toggle('expanded');"></span><a href="/Pages/Arduino/ESP8266">ESP8266</a>
    <ul>
      <li><span class="dtriangle" onclick="this.parentElement.classList.toggle('expanded');"></span><a href="/Pages/Arduino/ESP8266/A-Beginner's-Guide">A Beginner's Guide to the ESP8266</a>
      <ul>
      </ul>
      </li>
      <li><span class="dtriangle" onclick="this.parentElement.classList.toggle('expanded');"></span><a href="/Pages/Arduino/ESP8266/Flashing">Flashing</a>
      <ul>
      </ul>
      </li>
    </ul>
    </li>
  </ul>
  </li>
  <li class="expanded"><span class="dtriangle" onclick="this.parentElement.classList.toggle('expanded');"></span><a href="/Pages/Mathematics">Mathematics</a>
  <ul>
    <li class="expanded"><span class="dtriangle" onclick="this.parentElement.classList.toggle('expanded');"></span><a href="/Pages/Mathematics/Systems-and-Control-Theory">Systems and Control Theory</a>
    <ul>
      <li><span class="dtriangle" onclick="this.parentElement.classList.toggle('expanded');"></span><a href="/Pages/Mathematics/Systems-and-Control-Theory/Analog-Filters">Analog Filters</a>
      <ul>
      </ul>
      </li>
      <li class="expanded"><span class="dtriangle" onclick="this.parentElement.classList.toggle('expanded');"></span><a href="/Pages/Mathematics/Systems-and-Control-Theory/Digital-filters">Digital filters</a>
      <ul>
        <li><span class="dtriangle" onclick="this.parentElement.classList.toggle('expanded');"></span><a href="/Pages/Mathematics/Systems-and-Control-Theory/Digital-filters/DTLTI Systems, Transfer Functions, and the Z-transform">DTLTI Systems, Transfer Functions, and the Z-transform</a>
        <ul>
        </ul>
        </li>
        <li><span class="dtriangle" onclick="this.parentElement.classList.toggle('expanded');"></span><a href="/Pages/Mathematics/Systems-and-Control-Theory/Digital-filters/Discretization">Discretization</a>
        <ul>
        </ul>
        </li>
        <li><span class="dtriangle" onclick="this.parentElement.classList.toggle('expanded');"></span><a href="/Pages/Mathematics/Systems-and-Control-Theory/Digital-filters/Exponential Moving Average">Exponential Moving Average</a>
        <ul>
        </ul>
        </li>
        <li><span class="dtriangle" onclick="this.parentElement.classList.toggle('expanded');"></span><a href="/Pages/Mathematics/Systems-and-Control-Theory/Digital-filters/Simple Moving Average">Simple Moving Average</a>
        <ul>
        </ul>
        </li>
      </ul>
      </li>
    </ul>
    </li>
  </ul>
  </li>
  <li><span class="dtriangle" onclick="this.parentElement.classList.toggle('expanded');"></span><a href="/Pages/Ubuntu">Ubuntu</a>
  <ul>
    <li><span class="dtriangle" onclick="this.parentElement.classList.toggle('expanded');"></span><a href="/Pages/Ubuntu/Software-Installation">Software Installation</a>
    <ul>
    </ul>
    </li>
  </ul>
  </li>
</ul>

                <i class="material-icons">
                    <a href="/" title="Home">home</a>
                </i>
                <i class="material-icons">
                    <a href="FIR-Notch.pdf" title="Download as PDF">get_app</a>
                </i>
                <i class="material-icons">
                    <a href="javascript:window.print()" title="Print this article">print</a>
                </i>
                <i class="material-icons">
                    <a href="https://github.com/tttapa/tttapa.github.io/issues/new" target="_blank" title="Comment or open an issue">report</a>
                </i>
            </div>
        </nav>
        <article>
            <h1 class="title">Simple Finite Impulse Response Notch Filter</h1>
            <i class="author">Pieter P</i>
            <div>

<p>
This is an example on how to design a very simple FIR notch filter in the digital domain, 
that can be used to filter out 50/60 Hz mains noise, for example. <br>
It is a very simple filter, so the frequency response is not great, but it might be all you need.
It's only second order, finite impulse response, so very fast and always stable, and has linear phase.
</p>

<h3><a name="zero-placement" href="#zero-placement">Zero Placement</a></h3>
<p>
    To achieve notch characteristics, we'll just place a single complex pair of zeros on the unit circle.
    Let's say we have a sample frequency of \(360 \;\mathrm{Hz}\) and we want to filter out \(50 \;\mathrm{Hz}\) noise.
    <br>
    We'll first calculate the normalized frequency \(\omega_{c,d}\):
    $$ \begin{split}
     f_s &= 360 \;\mathrm{Hz} \\
     f_c &= 50 \;\mathrm{Hz} \\
     \omega_{c} &= 2\pi f_c \approx 314.2 \;\mathrm{rad} \;s^{-1} \\
     \omega_{c,d} &= \frac{\omega_c}{f_s} \approx 0.8727 \frac{\mathrm{rad}}{\mathrm{sample}} 
     \end{split} $$

     We know that the frequency response \(H(\omega)\)of a digital filter is just the transfer function \(H(z)\)
     evaluated along the unit circle \(z = e^{j\omega}\). In other words, we just need a transfer function that is zero
     when the frequency equals \(\omega_{c,d}\), or when \(z = e^{j\omega_{c,d}}\). Because the transer function must have
     real coefficients, the complex conjugate will be a zero as well: \(z = e^{-j\omega_{c,d}}\).
     $$ H(z) = \left(z - e^{j\omega_{c,d}}\right)\left(z - e^{-j\omega_{c,d}}\right) $$
     We can further simplify this function by expanding it, and using the identity 
     \(\cos(\theta) = \frac{e^{j\theta} + e^{-j\theta}}{2}\):
     $$ \begin{split} H(z) &= z^2 - z\left(e^{j\omega_{c,d}} + e^{-j\omega_{c,d}}\right) + e^{j\omega_{c,d}}e^{-j\omega_{c,d}} \\
     &= z^2 - 2\cos\left(\omega_{c,d}\right)z + 1 \end{split} $$
</p>
<h3><a name="normalization" href="#normalization">Normalization</a></h3>
<p>
    If we want a filter with a unit DC gain (\(H(1) = 1\)), we can just normalize the transfer function:
    $$ H_n(z) = \frac{H(z)}{H(1)} = \frac{z^2 - 2\cos\left(\omega_{c,d}\right)z + 1}{2 - 2\cos\left(\omega_{c,d}\right)} $$
</p>
<h3><a name="numerical-result" href="#numerical-result">Numerical Result</a></h3>
<p>
    Finally, we can just plug in the value of \(\omega_{c,d}\):
    $$ H_n(z) \approx \frac{z^2 - 1.286z + 1}{0.7144} = 1.400z^2 - 1.800z + 1.400 $$

</p>
<h3><a name="bode-plot-zero-map" href="#bode-plot-zero-map">Bode Plot &amp; Zero Map</a></h3>
<p>
    Let's take a quick look at the bode plot and the locations of the zeros. 
    The Python code to generate the Bode plot can be found below.

    <img src="images/Bode-notch-FIR.svg">
    <img src="images/pz-notch.svg">

    You can clearly see the expected linear phase of a FIR filter, with a 180 phase jump when the frequency crosses the zero.
    The notch itself is not at all narrow. If you want a narrower notch, you could a higher FIR order, or place some poles 
    close to the unit circle to cancel the effect of the zero.

    <pre class="lineNumbers"><code>from scipy.signal import butter, freqz </code>
<code>import matplotlib.pyplot as plt</code>
<code>from math import pi, cos</code>
<code>import numpy as np</code>
<code></code>
<code>f_s = 360    # Sample frequency in Hz</code>
<code>f_c = 50     # Notch frequency in Hz</code>
<code></code>
<code>omega_c = 2 * pi * f_c       # Notch angular frequency</code>
<code>omega_c_d = omega_c / f_s    # Normalized notch frequency (digital)</code>
<code></code>
<code>h_0 = 2 - 2 * cos(omega_c_d)</code>
<code>b = np.array((1, -2 * cos(omega_c_d), 1))   # Calculate coefficients</code>
<code>b /= h_0                                    # Normalize</code>
<code>a = 1</code>
<code>print("a =", a)                      # Print the coefficients</code>
<code>print("b =", b)</code>
<code></code>
<code>w, h = freqz(b, a)                   # Calculate the frequency response</code>
<code>w *= f_s / (2 * pi)                  # Convert from rad/sample to Hz</code>
<code></code>
<code>plt.subplot(2, 1, 1)                 # Plot the amplitude response</code>
<code>plt.suptitle('Bode Plot')            </code>
<code>plt.plot(w, 20 * np.log10(abs(h)))   # Convert to dB</code>
<code>plt.ylabel('Magnitude [dB]')</code>
<code>plt.xlim(0, f_s / 2)</code>
<code>plt.ylim(-60, 20)</code>
<code>plt.axvline(f_c, color='red')</code>
<code></code>
<code>plt.subplot(2, 1, 2)                 # Plot the phase response</code>
<code>plt.plot(w, 180 * np.angle(h) / pi)  # Convert argument to degrees</code>
<code>plt.xlabel('Frequency [Hz]')</code>
<code>plt.ylabel('Phase [°]')</code>
<code>plt.xlim(0, f_s / 2)</code>
<code>plt.ylim(-90, 135)</code>
<code>plt.yticks([-90, -45, 0, 45, 90, 135])</code>
<code>plt.axvline(f_c, color='red')</code>
<code>plt.show()</code></pre>

</p>
</div>
        </article>
        <footer>Last edited: Monday, 07 January 2019 18:07 UTC</footer>
    </body>
</html>
