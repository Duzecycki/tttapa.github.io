<!--
@title: C++ Implementation
@author: Pieter P
@sequence: 30
@keywords: EMA, Exponential Moving Average, IIR filter, filters, DSP, C++, implementation, algorithm
@description: A very fast and efficient Exponential Moving Average implementation
              in C++.
-->
<html>

<h3>Dividing by Powers of 2</h3>
<p>
    The factor \(\alpha\) in the difference equation of the Exponential Moving 
    Average filter is a number between zero and one. There are two main ways to 
    implement this multiplication by \(\alpha\): Either we use floating point 
    numbers and calculate the multiplication directly, or we use integers, and 
    express the multiplication as a division by \(1/\alpha \gt 1\).<br>
    Both floating point multiplication and integer division are relatively 
    expensive operations, especially on embedded devices or microcontrollers.
</p>
<p>
    We can, however, choose the value for \(\alpha\) in such a way that 
    \(1/\alpha = 2^k, k \in \mathbb{N}\).<br>
    This is useful, because a division by a power of two can be replaced by a 
    very fast right bitshift:
    $$ \alpha \cdot x = \frac{x}{2^k} = x \gg k $$
</p>
<p>
    We can now rewrite the difference equation of the EMA with this optimization
    in mind:
    $$ \begin{split}
       y[n] &amp;= \alpha x[n] + (1 - \alpha) y[n-1] \\
            &amp;= y[n-1] + \alpha \left(x[n] - y[n-1]\right) \\
            &amp;= y[n-1] + \frac{x[n] - y[n-1]}{2^k} \\
            &amp;= y[n-1] + \left(x[n] - y[n-1]\right) \gg k 
       \end{split} $$
</p>
<h4>Negative Numbers</h4>
<p>
    There's one caveat though: this doesn't work for negative numbers. 
    For example, if we try to calculate the integer division \(-15 / 4\) using 
    this method, we get the following answer:
    $$ \begin{split}
       -15 / 4   &amp;= -15 \cdot 2^{-2} \\
       -15 \gg 2 &amp;= 0b11110001 \gg 2 \\
                 &amp;= 0b11111100 \\
                 &amp;= -4
       \end{split} $$
    This is not what we expected! Integer division in programming languages such
    as C++ returns the quotient truncated towards zero, so we would expect a 
    value of \(-3\). The result is close, but incorrect nonetheless.
</p>
<p>
    This means we'll have to be careful not to use this trick on any negative
    numbers. In our difference equation, both the input \(x[n]\) and the output
    \(y[n]\) will generally be positive numbers, so no problem there, but their
    difference can be negative. 
    This is a problem. We'll have to come up with a different representation of
    the difference equation that doesn't require us to divide any negative 
    numbers:
    $$ \begin{split}
       y[n] &amp;= y[n-1] + \alpha \left(x[n] - y[n-1]\right) \\
       y[n] &amp;= y[n-1] + \frac{x[n] - y[n-1]}{2^k} \\
       2^k y[n] &amp;= 2^k y[n-1] + x[n] - y[n-1] \\[8pt]
       &amp;\ z[n] \triangleq 2^k y[n] \Leftrightarrow y[n] = 2^{-k} z[n]\\[8pt]
       z[n] &amp;= z[n-1] + x[n] - 2^{-k} z[n-1]
       \end{split} $$
    We now have to prove that \(z[n-1]\) is greater than or equal to zero. 
    We'll prove this using induction:
    <div style="padding-left: 2em">
        <u>Base case</u>: \(\quad n-1 = -1\)
        <div style="padding: 0.75em">
            The value of \(z[-1]\) is the initial state of the system. We can 
            just choose any value, so we'll pick a value that's greater than or 
            equal to zero: \(z[-1] \ge 0\).
        </div>
        <u>Induction step</u>: \(\quad n\)
        <div style="padding: 0.75em">
            Given that \(z[n-1] \ge 0\), we can now use the difference equation 
            to prove that \(z[n]\) is also greater than zero:<br>
            $$ z[n] = z[n-1] + x[n] - 2^{-k} z[n-1] $$
            We know that the input \(x[n]\) is always zero or positive. <br>
            Since \(k \gt 1 \Rightarrow 2^{-k} \lt 1\), and since \(z[n-1]\) is 
            zero or positive as well, we know that \(z[n-1] \ge 2^{-k} z[n-1] 
            \Rightarrow z[n-1] - 2^{-k} z[n-1] \ge 0\).<br>
            Therefore, the entire right-hand side is always positive or zero, 
            because it is a sum of two numbers that are themselves greater than
            or equal to zero. \(\quad\Box\)
        </div>
    </div>
</p>
<h4>Rounding</h4>
<p>
    A final improvement we can make to our division algorithm is to round the
    result to the nearest integer, instead of truncating it towards zero.<br>
    Consider the rounded result of the division \(a/b\). We can then express it
    as a flooring of the result plus one half:
    $$ \begin{split} 
       \left\lfloor \frac{a}{b} \right\rceil &amp;= 
           \left\lfloor \frac{a}{b} + \frac{1}{2} \right\rfloor \\
        &amp;= \left\lfloor \frac{a + \frac{b}{2}}{b} \right\rfloor \\
       \end{split} $$
    When \(b\) is a power of two, this is equivalent to:
    $$ \begin{split} 
    \left\lfloor \frac{a}{2^k} \right\rceil &amp;= 
        \left\lfloor \frac{a}{2^k} + \frac{1}{2} \right\rfloor \\
     &amp;= \left\lfloor \frac{a + \frac{2^k}{2}}{2^k} \right\rfloor \\
     &amp;= \left\lfloor \frac{a + 2^{k-1}}{2^k} \right\rfloor \\
     &amp;= \left(a + 1 \ll \left(k-1\right)\right) \gg k \\
    \end{split} $$
</p>
<h3>Implementation in C++</h3>
<p>
    We now have everything in place to write an implementation of the EMA in 
    C++:
</p>

@codesnippet{
"name": "EMA.cpp",
"file": "resources/EMA.cpp"
}

<p>
    Note how we save \(z[n] - 2^{-k} z[n]\) instead of just \(z[n]\). Otherwise,
    we would have to calculate \(2^{-k} z[n]\) twice (once to calculate 
    \(y[n]\), and once on the next iteration to calculate \(2^{-k} z[n-1]\)),
    and that would be unnecessary.
</p>

</html>